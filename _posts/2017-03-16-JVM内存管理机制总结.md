---
layout:     post
title:      JVM内存管理机制总结
category: blog
description: 文章内容主要来源于自己阅读周志明《深入理解java虚拟机》的要点总结，包括自己的一些理解和资料查阅
---

## 1、JVM内存模型
![JVM内存模型图](/images/JVM/JVM内存模型图.png)
JVM中的内存区域主要分为程序计数器、栈（虚拟机栈和本地方法栈）、方法区、堆；其中栈区和程序计数器是每一个线程都独立拥有的私有区域，方法区和堆区是所有线程共享的公共区域。
### 1.1、程序计数器
程序计数器就是当前线程所执行的字节码的行号，分支、循环、异常处理等都是靠这个计数器来完成的。在多线程执行过程中，为了线程切换之后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。另外要注意的是当JVM在执行本地方法时，程序计数器的值为空（Undefined）。程序计数器是唯一一个没有规定OOM异常的区域。
### 1.2、栈区
通知所指的栈内存其实就是虚拟机栈，它的随着一个线程的产生而产生，消失而消失，其生命周期与线程同步，故而栈内存一定是线程私有的。栈的主要作用是用来描述方法执行的，方法在执行的同时都会创建一个栈帧（Stack Frame），栈帧用于存放局部变量表、操作数栈、动态链栈、方法出口等信息。
### 1.3、堆区
堆是JVM管理的最大的一块内存，是所有线程都共享的，所以在虚拟器启动的时候就创建了。堆的唯一目的就是存放对象的实例，所有对象和数组都要在堆上分配空间。堆的大小是可以通过虚拟机的参数来设置的，-Xmx:配置堆的最大空间大小、-Xms:配置对的初始空间大小。堆内存大致分为新生代（包括一个Eden和两个Survivor，E和S的默认大小为8:1）、老生代。
### 1.4、方法区
方法区主要用来存放类信息、常量、静态变量等，所以方法区也是线程共享的。在HotSpot中，为图方便，直接将方法区内存与堆内存中的永久代一样处理。
在方法区中的常量池有一类比较特殊的叫作运行时常量，运行时常量是指在运行期间产生的常量（其它常量早在编译期间就写入了方法区），如String类的intern()方法，会在运行期间往方法区中加入一个常量字符串。
## 2、JVM垃圾收集与内存分配策略
程序计数器和栈区内存随线程而生灭，不需要考虑内存回收问题，而堆和方法区则不一样。在进行垃圾回收时，首先要判断对象是否是垃圾，有些处理方法使用引用计数器（每有一个地方引用，计数器值就加一）来判断，但是很难处理循环引用问题，AB两个对象相互引用，而又不被任何其它对象引用，此时这两个对象已经是垃圾对象了，但是其引用计数器不为0，无法被回收。在JVM中使用的是可达性分析算法
### 2.1、可达性分析
用来判断对象是否存活，以"GC Roots"栈为起点，依次向小搜索，所有经过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，此对象就是不可用了，可以被回收。"Gc Roots"栈中主要包括：虚拟机栈中引用的对象、方法区中静态属性和常量引用的对象、JNI中引用的对象。
一个对象在进行可达性分析不可达后并不会直接回收，若其重写了finalize()方法并且没有被执行过（finalize()方法仅会被虚拟机执行一次），则会进入到F-Queue队列中，由低优先级的线程Finalizer执行。
在java中的引用被分为强引用、软引用、若引用、虚引用四种。
### 2.2、垃圾收集算法
#### 标记-清除算法（Mark-Sweep）
先标记，而后统一清除，是最基本的垃圾回收算法，会造成内存碎片
#### 复制算法
基本思想是将内存一分为二，其中一块用完了，就将还活着的对象复制到另外一块，然后将已使用过的那一块清除。（适合新生代）
####标记-整理算法
和标记-清除差不多，不过不是直接直接对垃圾对象进行清理，而是让存活的对象向一顿移动，以消除碎片。（适合老生代）
#### 分代收集算法
根据对象的存活周期，将堆划分为新生代、老生代，采取不同的收集算法。