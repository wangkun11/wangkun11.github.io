---
layout:     post
title:      JVM内存管理机制总结
category: blog
description: 文章内容主要来源于自己阅读周志明《深入理解java虚拟机》的要点总结，包括自己的一些理解和资料查阅
---

## 1、JVM内存模型
![JVM内存模型图](/images/JVM/JVM内存模型图.png)
JVM中的内存区域主要分为程序计数器、栈（虚拟机栈和本地方法栈）、方法区、堆；其中栈区和程序计数器是每一个线程都独立拥有的私有区域，方法区和堆区是所有线程共享的公共区域。
### 1.1、程序计数器
程序计数器就是当前线程所执行的字节码的行号，分支、循环、异常处理等都是靠这个计数器来完成的。在多线程执行过程中，为了线程切换之后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。另外要注意的是当JVM在执行本地方法时，程序计数器的值为空（Undefined）。程序计数器是唯一一个没有规定OOM异常的区域。
### 1.2、栈区
通知所指的栈内存其实就是虚拟机栈，它的随着一个线程的产生而产生，消失而消失，其生命周期与线程同步，故而栈内存一定是线程私有的。栈的主要作用是用来描述方法执行的，方法在执行的同时都会创建一个栈帧（Stack Frame），栈帧用于存放局部变量表、操作数栈、动态链栈、方法出口等信息。
### 1.3、堆区
堆是JVM管理的最大的一块内存，是所有线程都共享的，所以在虚拟器启动的时候就创建了。堆的唯一目的就是存放对象的实例，所有对象和数组都要在堆上分配空间。堆的大小是可以通过虚拟机的参数来设置的，-Xmx:配置堆的最大空间大小、-Xms:配置对的初始空间大小。堆内存大致分为新生代（包括一个Eden和两个Survivor，E和S的默认大小为8:1）、老生代。
### 1.4、方法区
方法区主要用来存放类信息、常量、静态变量等，所以方法区也是线程共享的。在HotSpot中，为图方便，直接将方法区内存与堆内存中的永久代一样处理。
在方法区中的常量池有一类比较特殊的叫作运行时常量，运行时常量是指在运行期间产生的常量（其它常量早在编译期间就写入了方法区），如String类的intern()方法，会在运行期间往方法区中加入一个常量字符串。
## 2、JVM垃圾收集与内存分配策略
程序计数器和栈区内存随线程而生灭，不需要考虑内存回收问题，而堆和方法区则不一样。在进行垃圾回收时，首先要判断对象是否是垃圾，有些处理方法使用引用计数器（每有一个地方引用，计数器值就加一）来判断，但是很难处理循环引用问题，AB两个对象相互引用，而又不被任何其它对象引用，此时这两个对象已经是垃圾对象了，但是其引用计数器不为0，无法被回收。在JVM中使用的是可达性分析算法
### 2.1、可达性分析
用来判断对象是否存活，以"GC Roots"栈为起点，依次向小搜索，所有经过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，此对象就是不可用了，可以被回收。"Gc Roots"栈中主要包括：虚拟机栈中引用的对象、方法区中静态属性和常量引用的对象、JNI中引用的对象。
一个对象在进行可达性分析不可达后并不会直接回收，若其重写了finalize()方法并且没有被执行过（finalize()方法仅会被虚拟机执行一次），则会进入到F-Queue队列中，由低优先级的线程Finalizer执行。
在java中的引用被分为强引用、软引用、若引用、虚引用四种。
### 2.2、垃圾收集算法
* 标记-清除算法（Mark-Sweep）：
先标记，而后统一清除，是最基本的垃圾回收算法，会造成内存碎片。
* 复制算法：
基本思想是将内存一分为二，其中一块用完了，就将还活着的对象复制到另外一块，然后将已使用过的那一块清除。（适合新生代）
* 标记-整理算法：
和标记-清除差不多，不过不是直接直接对垃圾对象进行清理，而是让存活的对象向一顿移动，以消除碎片。（适合老生代）
* 分代收集算法：
根据对象的存活周期，将堆划分为新生代、老生代，采取不同的收集算法。
### 2.3、HotSpot的实现
可达性分析时，必须停顿所有线程（Stop The World），以保证对象的引用关系不发生变化；为了减少GC过程中STW的耗时，HotSpot使用准确式GC，即当系统停顿下来之后，并不需要检查完所有的上下文和全局变量的位置，而是用一组OopMap来记录栈和寄存器中哪些位置是引用，这样GC在扫描的时候就可以直接知道了。
在OopMap的协助下，HotSpot可以快速而准确的完成一次枚举，并且为了减小OopMap的大小，HopSpot并没有为每条指令都生成OopMap,只是在“安全点”记录这些信息。所有程序并不是在所有地方都能停顿下来开始GC,只有在到达安全点的时候才能GC。
另外一个问题是，在执行GC的时候并不是所有线程都跑到安全点，为了让线程运行到安全点再停顿，一般有两种方式：
* 抢占式中断:发生GC时首先把所有线程全部中断，发现有线程不在安全点上，就恢复线程，让其跑到安全点；
* 主动式中断：GC要中断的时候，不直接对线程操作，而是设置一个Flag，各线程执行的过程中主动轮询这个标志，发现标志为真时就自己主动挂起。
## 3、内存分配与回收策略
* 对象优先分配在Eden上：大多数情况下，对象直接分配在Eden上，当Eden没有足够的空间分配时，JVM将发起一次Minor GC（只针对新生代），
* 大对象直接进入老年代
* 长期存活的对象从新生代进入老年代：JVM才用分代收集的思想来管理内存，给每个对象定义一个Age（年龄）计数器，新生对象最开始出生在Eden中，经过一次Minor GC任然存过并且能被Survivor的话，将被移动到Survivor中，并且Age设置为1，以后每经历一次Minor GC，Age都会加一，默认Age增加到15就会晋升到老年代中去；
* 动态判定对象年龄：如果Survivor中相同年龄所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以进入老年代。
* 空间分配担保：在发生Minor GC前，JVM会检查老年代最大连续可用空间是否大于新生代所有对象总和，如果大于则可以确定Minor GC是安全的，直接Minor GC；否则会检查老年带最大连续可用内存是否大于历次晋升老年代的对象平均大小，如果是则尝试进行一次有风险的Minor GC,如果此次Minor GC失败（即老年代都无法容纳新生对象），则此处需要进行一次Full GC。